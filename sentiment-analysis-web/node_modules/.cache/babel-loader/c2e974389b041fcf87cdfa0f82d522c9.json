{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar dragElement = require('../../dragelement');\n\nvar dragHelpers = require('../../dragelement/helpers');\n\nvar drawMode = dragHelpers.drawMode;\n\nvar Registry = require('../../../registry');\n\nvar constants = require('./constants');\n\nvar i000 = constants.i000;\nvar i090 = constants.i090;\nvar i180 = constants.i180;\nvar i270 = constants.i270;\n\nvar handleOutline = require('../../../plots/cartesian/handle_outline');\n\nvar clearOutlineControllers = handleOutline.clearOutlineControllers;\n\nvar helpers = require('./helpers');\n\nvar pointsShapeRectangle = helpers.pointsShapeRectangle;\nvar pointsShapeEllipse = helpers.pointsShapeEllipse;\nvar writePaths = helpers.writePaths;\n\nvar newShapes = require('./newshapes');\n\nmodule.exports = function displayOutlines(polygons, outlines, dragOptions, nCalls) {\n  if (!nCalls) nCalls = 0;\n  var gd = dragOptions.gd;\n\n  function redraw() {\n    // recursive call\n    displayOutlines(polygons, outlines, dragOptions, nCalls++);\n\n    if (pointsShapeEllipse(polygons[0])) {\n      update({\n        redrawing: true\n      });\n    }\n  }\n\n  function update(opts) {\n    dragOptions.isActiveShape = false; // i.e. to disable controllers\n\n    var updateObject = newShapes(outlines, dragOptions);\n\n    if (Object.keys(updateObject).length) {\n      Registry.call((opts || {}).redrawing ? 'relayout' : '_guiRelayout', gd, updateObject);\n    }\n  }\n\n  var isActiveShape = dragOptions.isActiveShape;\n  var fullLayout = gd._fullLayout;\n  var zoomLayer = fullLayout._zoomlayer;\n  var dragmode = dragOptions.dragmode;\n  var isDrawMode = drawMode(dragmode);\n  if (isDrawMode) gd._fullLayout._drawing = true;else if (gd._fullLayout._activeShapeIndex >= 0) clearOutlineControllers(gd); // make outline\n\n  outlines.attr('d', writePaths(polygons)); // add controllers\n\n  var vertexDragOptions;\n  var shapeDragOptions;\n  var indexI; // cell index\n\n  var indexJ; // vertex or cell-controller index\n\n  var copyPolygons;\n\n  if (isActiveShape && !nCalls) {\n    copyPolygons = recordPositions([], polygons);\n    var g = zoomLayer.append('g').attr('class', 'outline-controllers');\n    addVertexControllers(g);\n    addShapeControllers();\n  }\n\n  function startDragVertex(evt) {\n    indexI = +evt.srcElement.getAttribute('data-i');\n    indexJ = +evt.srcElement.getAttribute('data-j');\n    vertexDragOptions[indexI][indexJ].moveFn = moveVertexController;\n  }\n\n  function moveVertexController(dx, dy) {\n    if (!polygons.length) return;\n    var x0 = copyPolygons[indexI][indexJ][1];\n    var y0 = copyPolygons[indexI][indexJ][2];\n    var cell = polygons[indexI];\n    var len = cell.length;\n\n    if (pointsShapeRectangle(cell)) {\n      for (var q = 0; q < len; q++) {\n        if (q === indexJ) continue; // move other corners of rectangle\n\n        var pos = cell[q];\n\n        if (pos[1] === cell[indexJ][1]) {\n          pos[1] = x0 + dx;\n        }\n\n        if (pos[2] === cell[indexJ][2]) {\n          pos[2] = y0 + dy;\n        }\n      } // move the corner\n\n\n      cell[indexJ][1] = x0 + dx;\n      cell[indexJ][2] = y0 + dy;\n\n      if (!pointsShapeRectangle(cell)) {\n        // reject result to rectangles with ensure areas\n        for (var j = 0; j < len; j++) {\n          for (var k = 0; k < cell[j].length; k++) {\n            cell[j][k] = copyPolygons[indexI][j][k];\n          }\n        }\n      }\n    } else {\n      // other polylines\n      cell[indexJ][1] = x0 + dx;\n      cell[indexJ][2] = y0 + dy;\n    }\n\n    redraw();\n  }\n\n  function endDragVertexController() {\n    update();\n  }\n\n  function removeVertex() {\n    if (!polygons.length) return;\n    if (!polygons[indexI]) return;\n    if (!polygons[indexI].length) return;\n    var newPolygon = [];\n\n    for (var j = 0; j < polygons[indexI].length; j++) {\n      if (j !== indexJ) {\n        newPolygon.push(polygons[indexI][j]);\n      }\n    }\n\n    if (newPolygon.length > 1 && !(newPolygon.length === 2 && newPolygon[1][0] === 'Z')) {\n      if (indexJ === 0) {\n        newPolygon[0][0] = 'M';\n      }\n\n      polygons[indexI] = newPolygon;\n      redraw();\n      update();\n    }\n  }\n\n  function clickVertexController(numClicks, evt) {\n    if (numClicks === 2) {\n      indexI = +evt.srcElement.getAttribute('data-i');\n      indexJ = +evt.srcElement.getAttribute('data-j');\n      var cell = polygons[indexI];\n\n      if (!pointsShapeRectangle(cell) && !pointsShapeEllipse(cell)) {\n        removeVertex();\n      }\n    }\n  }\n\n  function addVertexControllers(g) {\n    vertexDragOptions = [];\n\n    for (var i = 0; i < polygons.length; i++) {\n      var cell = polygons[i];\n      var onRect = pointsShapeRectangle(cell);\n      var onEllipse = !onRect && pointsShapeEllipse(cell);\n      vertexDragOptions[i] = [];\n\n      for (var j = 0; j < cell.length; j++) {\n        if (cell[j][0] === 'Z') continue;\n\n        if (onEllipse && j !== i000 && j !== i090 && j !== i180 && j !== i270) {\n          continue;\n        }\n\n        var x = cell[j][1];\n        var y = cell[j][2];\n        var vertex = g.append('circle').classed('cursor-grab', true).attr('data-i', i).attr('data-j', j).attr('cx', x).attr('cy', y).attr('r', 4).style({\n          'mix-blend-mode': 'luminosity',\n          fill: 'black',\n          stroke: 'white',\n          'stroke-width': 1\n        });\n        vertexDragOptions[i][j] = {\n          element: vertex.node(),\n          gd: gd,\n          prepFn: startDragVertex,\n          doneFn: endDragVertexController,\n          clickFn: clickVertexController\n        };\n        dragElement.init(vertexDragOptions[i][j]);\n      }\n    }\n  }\n\n  function moveShape(dx, dy) {\n    if (!polygons.length) return;\n\n    for (var i = 0; i < polygons.length; i++) {\n      for (var j = 0; j < polygons[i].length; j++) {\n        for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {\n          polygons[i][j][k + 1] = copyPolygons[i][j][k + 1] + dx;\n          polygons[i][j][k + 2] = copyPolygons[i][j][k + 2] + dy;\n        }\n      }\n    }\n  }\n\n  function moveShapeController(dx, dy) {\n    moveShape(dx, dy);\n    redraw();\n  }\n\n  function startDragShapeController(evt) {\n    indexI = +evt.srcElement.getAttribute('data-i');\n    if (!indexI) indexI = 0; // ensure non-existing move button get zero index\n\n    shapeDragOptions[indexI].moveFn = moveShapeController;\n  }\n\n  function endDragShapeController() {\n    update();\n  }\n\n  function addShapeControllers() {\n    shapeDragOptions = [];\n    if (!polygons.length) return;\n    var i = 0;\n    shapeDragOptions[i] = {\n      element: outlines[0][0],\n      gd: gd,\n      prepFn: startDragShapeController,\n      doneFn: endDragShapeController\n    };\n    dragElement.init(shapeDragOptions[i]);\n  }\n};\n\nfunction recordPositions(polygonsOut, polygonsIn) {\n  for (var i = 0; i < polygonsIn.length; i++) {\n    var cell = polygonsIn[i];\n    polygonsOut[i] = [];\n\n    for (var j = 0; j < cell.length; j++) {\n      polygonsOut[i][j] = [];\n\n      for (var k = 0; k < cell[j].length; k++) {\n        polygonsOut[i][j][k] = cell[j][k];\n      }\n    }\n  }\n\n  return polygonsOut;\n}","map":null,"metadata":{},"sourceType":"script"}