{"ast":null,"code":"'use strict';\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n **/\n\nvar SIZE_HEADER = 4 + 4; // 8\n\nvar FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n *\n **/\n\nvar ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n\nfunction isICNS(buffer) {\n  return 'icns' === buffer.toString('ascii', 0, 4);\n}\n\nvar ICON_TYPE_SIZE = {\n  ICON: 32,\n  'ICN#': 32,\n  // m => 16 x 16\n  'icm#': 16,\n  icm4: 16,\n  icm8: 16,\n  // s => 16 x 16\n  'ics#': 16,\n  ics4: 16,\n  ics8: 16,\n  is32: 16,\n  s8mk: 16,\n  icp4: 16,\n  // l => 32 x 32\n  icl4: 32,\n  icl8: 32,\n  il32: 32,\n  l8mk: 32,\n  icp5: 32,\n  ic11: 32,\n  // h => 48 x 48\n  ich4: 48,\n  ich8: 48,\n  ih32: 48,\n  h8mk: 48,\n  // . => 64 x 64\n  icp6: 64,\n  ic12: 32,\n  // t => 128 x 128\n  it32: 128,\n  t8mk: 128,\n  ic07: 128,\n  // . => 256 x 256\n  ic08: 256,\n  ic13: 256,\n  // . => 512 x 512\n  ic09: 512,\n  ic14: 512,\n  // . => 1024 x 1024\n  ic10: 1024\n};\n\nfunction readImageHeader(buffer, imageOffset) {\n  var imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET; // returns [type, length]\n\n  return [buffer.toString('ascii', imageOffset, imageLengthOffset), buffer.readUInt32BE(imageLengthOffset)];\n}\n\nfunction getImageSize(type) {\n  var size = ICON_TYPE_SIZE[type];\n  return {\n    width: size,\n    height: size,\n    type: type\n  };\n}\n\nfunction calculate(buffer) {\n  var bufferLength = buffer.length,\n      imageOffset = SIZE_HEADER,\n      fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET),\n      imageHeader,\n      imageSize,\n      result;\n  imageHeader = readImageHeader(buffer, imageOffset);\n  imageSize = getImageSize(imageHeader[0]);\n  imageOffset += imageHeader[1];\n\n  if (imageOffset === fileLength) {\n    return imageSize;\n  }\n\n  result = {\n    width: imageSize.width,\n    height: imageSize.height,\n    images: [imageSize]\n  };\n\n  while (imageOffset < fileLength && imageOffset < bufferLength) {\n    imageHeader = readImageHeader(buffer, imageOffset);\n    imageSize = getImageSize(imageHeader[0]);\n    imageOffset += imageHeader[1];\n    result.images.push(imageSize);\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  'detect': isICNS,\n  'calculate': calculate\n};","map":null,"metadata":{},"sourceType":"script"}