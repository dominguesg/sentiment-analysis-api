{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar polybool = require('polybooljs');\n\nvar Registry = require('../../registry');\n\nvar dashStyle = require('../../components/drawing').dashStyle;\n\nvar Color = require('../../components/color');\n\nvar Fx = require('../../components/fx');\n\nvar makeEventData = require('../../components/fx/helpers').makeEventData;\n\nvar dragHelpers = require('../../components/dragelement/helpers');\n\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\nvar selectMode = dragHelpers.selectMode;\n\nvar displayOutlines = require('../../components/shapes/draw_newshape/display_outlines');\n\nvar handleEllipse = require('../../components/shapes/draw_newshape/helpers').handleEllipse;\n\nvar newShapes = require('../../components/shapes/draw_newshape/newshapes');\n\nvar Lib = require('../../lib');\n\nvar polygon = require('../../lib/polygon');\n\nvar throttle = require('../../lib/throttle');\n\nvar getFromId = require('./axis_ids').getFromId;\n\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar constants = require('./constants');\n\nvar MINSELECT = constants.MINSELECT;\nvar filteredPolygon = polygon.filter;\nvar polygonTester = polygon.tester;\n\nvar clearSelect = require('./handle_outline').clearSelect;\n\nvar helpers = require('./helpers');\n\nvar p2r = helpers.p2r;\nvar axValue = helpers.axValue;\nvar getTransform = helpers.getTransform;\n\nfunction prepSelect(e, startX, startY, dragOptions, mode) {\n  var isFreeMode = freeMode(mode);\n  var isRectMode = rectMode(mode);\n  var isOpenMode = openMode(mode);\n  var isDrawMode = drawMode(mode);\n  var isSelectMode = selectMode(mode);\n  var isLine = mode === 'drawline';\n  var isEllipse = mode === 'drawcircle';\n  var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions\n\n  var gd = dragOptions.gd;\n  var fullLayout = gd._fullLayout;\n  var zoomLayer = fullLayout._zoomlayer;\n  var dragBBox = dragOptions.element.getBoundingClientRect();\n  var plotinfo = dragOptions.plotinfo;\n  var transform = getTransform(plotinfo);\n  var x0 = startX - dragBBox.left;\n  var y0 = startY - dragBBox.top;\n\n  fullLayout._calcInverseTransform(gd);\n\n  var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n  x0 = transformedCoords[0];\n  y0 = transformedCoords[1];\n  var scaleX = fullLayout._invScaleX;\n  var scaleY = fullLayout._invScaleY;\n  var x1 = x0;\n  var y1 = y0;\n  var path0 = 'M' + x0 + ',' + y0;\n  var pw = dragOptions.xaxes[0]._length;\n  var ph = dragOptions.yaxes[0]._length;\n  var allAxes = dragOptions.xaxes.concat(dragOptions.yaxes);\n  var subtract = e.altKey && !(drawMode(mode) && isOpenMode);\n  var filterPoly, selectionTester, mergedPolygons, currentPolygon;\n  var i, searchInfo, eventData;\n  coerceSelectionsCache(e, gd, dragOptions);\n\n  if (isFreeMode) {\n    filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n  }\n\n  var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data(isDrawMode ? [0] : [1, 2]);\n  var drwStyle = fullLayout.newshape;\n  outlines.enter().append('path').attr('class', function (d) {\n    return 'select-outline select-outline-' + d + ' select-outline-' + plotinfo.id;\n  }).style(isDrawMode ? {\n    opacity: drwStyle.opacity / 2,\n    fill: isOpenMode ? undefined : drwStyle.fillcolor,\n    stroke: drwStyle.line.color,\n    'stroke-dasharray': dashStyle(drwStyle.line.dash, drwStyle.line.width),\n    'stroke-width': drwStyle.line.width + 'px'\n  } : {}).attr('fill-rule', drwStyle.fillrule).classed('cursor-move', isDrawMode ? true : false).attr('transform', transform).attr('d', path0 + 'Z');\n  var corners = zoomLayer.append('path').attr('class', 'zoombox-corners').style({\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': 1\n  }).attr('transform', transform).attr('d', 'M0,0Z');\n  var throttleID = fullLayout._uid + constants.SELECTID;\n  var selection = []; // find the traces to search for selection points\n\n  var searchTraces = determineSearchTraces(gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot);\n\n  function ascending(a, b) {\n    return a - b;\n  } // allow subplots to override fillRangeItems routine\n\n\n  var fillRangeItems;\n\n  if (plotinfo.fillRangeItems) {\n    fillRangeItems = plotinfo.fillRangeItems;\n  } else {\n    if (isRectMode) {\n      fillRangeItems = function fillRangeItems(eventData, poly) {\n        var ranges = eventData.range = {};\n\n        for (i = 0; i < allAxes.length; i++) {\n          var ax = allAxes[i];\n\n          var axLetter = ax._id.charAt(0);\n\n          ranges[ax._id] = [p2r(ax, poly[axLetter + 'min']), p2r(ax, poly[axLetter + 'max'])].sort(ascending);\n        }\n      };\n    } else {\n      // case of isFreeMode\n      fillRangeItems = function fillRangeItems(eventData, poly, filterPoly) {\n        var dataPts = eventData.lassoPoints = {};\n\n        for (i = 0; i < allAxes.length; i++) {\n          var ax = allAxes[i];\n          dataPts[ax._id] = filterPoly.filtered.map(axValue(ax));\n        }\n      };\n    }\n  }\n\n  dragOptions.moveFn = function (dx0, dy0) {\n    x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));\n    y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));\n    var dx = Math.abs(x1 - x0);\n    var dy = Math.abs(y1 - y0);\n\n    if (isRectMode) {\n      var direction;\n      var start, end;\n\n      if (isSelectMode) {\n        var q = fullLayout.selectdirection;\n\n        if (q === 'any') {\n          if (dy < Math.min(dx * 0.6, MINSELECT)) {\n            direction = 'h';\n          } else if (dx < Math.min(dy * 0.6, MINSELECT)) {\n            direction = 'v';\n          } else {\n            direction = 'd';\n          }\n        } else {\n          direction = q;\n        }\n\n        switch (direction) {\n          case 'h':\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n\n          case 'v':\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n        }\n      }\n\n      if (isDrawMode) {\n        switch (fullLayout.newshape.drawdirection) {\n          case 'vertical':\n            direction = 'h';\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n\n          case 'horizontal':\n            direction = 'v';\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n\n          case 'ortho':\n            if (dx < dy) {\n              direction = 'h';\n              start = y0;\n              end = y1;\n            } else {\n              direction = 'v';\n              start = x0;\n              end = x1;\n            }\n\n            break;\n\n          default:\n            // i.e. case of 'diagonal'\n            direction = 'd';\n        }\n      }\n\n      if (direction === 'h') {\n        // horizontal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) : // using x1 instead of x0 allows adjusting the line while drawing\n        [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box\n\n        currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);\n        currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(start, end);\n        currentPolygon.ymax = Math.max(start, end); // extras to guide users in keeping a straight selection\n\n        corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) + 'h-4v' + 2 * MINSELECT + 'h4Z' + 'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) + 'h4v' + 2 * MINSELECT + 'h-4Z');\n      } else if (direction === 'v') {\n        // vertical motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) : // using y1 instead of y0 allows adjusting the line while drawing\n        [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box\n\n        currentPolygon.xmin = Math.min(start, end);\n        currentPolygon.xmax = Math.max(start, end);\n        currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);\n        currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);\n        corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin + 'v-4h' + 2 * MINSELECT + 'v4Z' + 'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) + 'v4h' + 2 * MINSELECT + 'v-4Z');\n      } else if (direction === 'd') {\n        // diagonal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n        currentPolygon.xmin = Math.min(x0, x1);\n        currentPolygon.xmax = Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(y0, y1);\n        currentPolygon.ymax = Math.max(y0, y1);\n        corners.attr('d', 'M0,0Z');\n      }\n    } else if (isFreeMode) {\n      filterPoly.addPt([x1, y1]);\n      currentPolygon = filterPoly.filtered;\n    } // create outline & tester\n\n\n    if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n      mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n      currentPolygon.subtract = subtract;\n      selectionTester = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTester = polygonTester(currentPolygon);\n    } // display polygons on the screen\n\n\n    displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);\n\n    if (isSelectMode) {\n      throttle.throttle(throttleID, constants.SELECTDELAY, function () {\n        selection = [];\n        var thisSelection;\n        var traceSelections = [];\n        var traceSelection;\n\n        for (i = 0; i < searchTraces.length; i++) {\n          searchInfo = searchTraces[i];\n          traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTester);\n          traceSelections.push(traceSelection);\n          thisSelection = fillSelectionItem(traceSelection, searchInfo);\n\n          if (selection.length) {\n            for (var j = 0; j < thisSelection.length; j++) {\n              selection.push(thisSelection[j]);\n            }\n          } else selection = thisSelection;\n        }\n\n        eventData = {\n          points: selection\n        };\n        updateSelectedState(gd, searchTraces, eventData);\n        fillRangeItems(eventData, currentPolygon, filterPoly);\n        dragOptions.gd.emit('plotly_selecting', eventData);\n      });\n    }\n  };\n\n  dragOptions.clickFn = function (numClicks, evt) {\n    corners.remove();\n\n    if (gd._fullLayout._activeShapeIndex >= 0) {\n      gd._fullLayout._deactivateShape(gd);\n\n      return;\n    }\n\n    if (isDrawMode) return;\n    var clickmode = fullLayout.clickmode;\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n\n      if (numClicks === 2) {\n        // clear selection on doubleclick\n        outlines.remove();\n\n        for (i = 0; i < searchTraces.length; i++) {\n          searchInfo = searchTraces[i];\n\n          searchInfo._module.selectPoints(searchInfo, false);\n        }\n\n        updateSelectedState(gd, searchTraces);\n        clearSelectionsCache(dragOptions);\n        gd.emit('plotly_deselect', null);\n      } else {\n        if (clickmode.indexOf('select') > -1) {\n          selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot, dragOptions, outlines);\n        }\n\n        if (clickmode === 'event') {\n          // TODO: remove in v2 - this was probably never intended to work as it does,\n          // but in case anyone depends on it we don't want to break it now.\n          // Note that click-to-select introduced pre v2 also emitts proper\n          // event data when clickmode is having 'select' in its flag list.\n          gd.emit('plotly_selected', undefined);\n        }\n      }\n\n      Fx.click(gd, evt);\n    }).catch(Lib.error);\n  };\n\n  dragOptions.doneFn = function () {\n    corners.remove();\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n      dragOptions.gd.emit('plotly_selected', eventData);\n\n      if (currentPolygon && dragOptions.selectionDefs) {\n        // save last polygons\n        currentPolygon.subtract = subtract;\n        dragOptions.selectionDefs.push(currentPolygon); // we have to keep reference to arrays container\n\n        dragOptions.mergedPolygons.length = 0;\n        [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n      }\n\n      if (dragOptions.doneFnCompleted) {\n        dragOptions.doneFnCompleted(selection);\n      }\n    }).catch(Lib.error);\n\n    if (isDrawMode) {\n      clearSelectionsCache(dragOptions);\n    }\n  };\n}\n\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n  var hoverData = gd._hoverdata;\n  var fullLayout = gd._fullLayout;\n  var clickmode = fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1;\n  var selection = [];\n  var searchTraces, searchInfo, currentSelectionDef, selectionTester, traceSelection;\n  var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n\n  if (isHoverDataSet(hoverData)) {\n    coerceSelectionsCache(evt, gd, dragOptions);\n    searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n    var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n    var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0; // Note: potentially costly operation isPointOrBinSelected is\n    // called as late as possible through the use of an assignment\n    // in an if condition.\n\n    if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n      if (polygonOutlines) polygonOutlines.remove();\n\n      for (i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n\n        searchInfo._module.selectPoints(searchInfo, false);\n      }\n\n      updateSelectedState(gd, searchTraces);\n      clearSelectionsCache(dragOptions);\n\n      if (sendEvents) {\n        gd.emit('plotly_deselect', null);\n      }\n    } else {\n      subtract = evt.shiftKey && (pointOrBinSelected !== undefined ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));\n      currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n      var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n      selectionTester = multiTester(allSelectionDefs);\n\n      for (i = 0; i < searchTraces.length; i++) {\n        traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTester);\n        thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n\n        if (selection.length) {\n          for (var j = 0; j < thisTracesSelection.length; j++) {\n            selection.push(thisTracesSelection[j]);\n          }\n        } else selection = thisTracesSelection;\n      }\n\n      eventData = {\n        points: selection\n      };\n      updateSelectedState(gd, searchTraces, eventData);\n\n      if (currentSelectionDef && dragOptions) {\n        dragOptions.selectionDefs.push(currentSelectionDef);\n      }\n\n      if (polygonOutlines) {\n        var polygons = dragOptions.mergedPolygons;\n        var isOpenMode = openMode(dragOptions.dragmode); // display polygons on the screen\n\n        displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);\n      }\n\n      if (sendEvents) {\n        gd.emit('plotly_selected', eventData);\n      }\n    }\n  }\n}\n/**\n * Constructs a new point selection definition object.\n */\n\n\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n  return {\n    pointNumber: pointNumber,\n    searchInfo: searchInfo,\n    subtract: subtract\n  };\n}\n\nfunction isPointSelectionDef(o) {\n  return 'pointNumber' in o && 'searchInfo' in o;\n}\n/*\n * Constructs a new point number tester.\n */\n\n\nfunction newPointNumTester(pointSelectionDef) {\n  return {\n    xmin: 0,\n    xmax: 0,\n    ymin: 0,\n    ymax: 0,\n    pts: [],\n    contains: function contains(pt, omitFirstEdge, pointNumber, searchInfo) {\n      var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n      var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n      return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;\n    },\n    isRect: false,\n    degenerate: false,\n    subtract: pointSelectionDef.subtract\n  };\n}\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\n\n\nfunction multiTester(list) {\n  var testers = [];\n  var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n  var xmax = xmin;\n  var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n  var ymax = ymin;\n\n  for (var i = 0; i < list.length; i++) {\n    if (isPointSelectionDef(list[i])) {\n      testers.push(newPointNumTester(list[i]));\n    } else {\n      var tester = polygon.tester(list[i]);\n      tester.subtract = list[i].subtract;\n      testers.push(tester);\n      xmin = Math.min(xmin, tester.xmin);\n      xmax = Math.max(xmax, tester.xmax);\n      ymin = Math.min(ymin, tester.ymin);\n      ymax = Math.max(ymax, tester.ymax);\n    }\n  }\n  /**\n   * Tests if the given point is within this tester.\n   *\n   * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n   * @param {*} arg - An optional parameter to pass down to wrapped testers.\n   * @param {number} pointNumber - The point number of the point within the underlying data array.\n   * @param {number} searchInfo - An object identifying the trace the point is contained in.\n   *\n   * @return {boolean} true if point is considered to be selected, false otherwise.\n   */\n\n\n  function contains(pt, arg, pointNumber, searchInfo) {\n    var contained = false;\n\n    for (var i = 0; i < testers.length; i++) {\n      if (testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n        // if contained by subtract tester - exclude the point\n        contained = testers[i].subtract === false;\n      }\n    }\n\n    return contained;\n  }\n\n  return {\n    xmin: xmin,\n    xmax: xmax,\n    ymin: ymin,\n    ymax: ymax,\n    pts: [],\n    contains: contains,\n    isRect: false,\n    degenerate: false\n  };\n}\n\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n  gd._fullLayout._drawing = false;\n  var fullLayout = gd._fullLayout;\n  var plotinfo = dragOptions.plotinfo;\n  var dragmode = dragOptions.dragmode;\n  var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;\n  var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));\n\n  if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {\n    // take over selection definitions from prev mode, if any\n    dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n    dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n  } else if (!hasModifierKey || !plotinfo.selection) {\n    clearSelectionsCache(dragOptions);\n  } // clear selection outline when selecting a different subplot\n\n\n  if (!selectingOnSameSubplot) {\n    clearSelect(gd);\n    fullLayout._lastSelectedSubplot = plotinfo.id;\n  }\n}\n\nfunction clearSelectionsCache(dragOptions) {\n  var dragmode = dragOptions.dragmode;\n  var plotinfo = dragOptions.plotinfo;\n  var gd = dragOptions.gd;\n\n  if (gd._fullLayout._activeShapeIndex >= 0) {\n    gd._fullLayout._deactivateShape(gd);\n  }\n\n  if (drawMode(dragmode)) {\n    var fullLayout = gd._fullLayout;\n    var zoomLayer = fullLayout._zoomlayer;\n    var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n\n    if (outlines && gd._fullLayout._drawing) {\n      // add shape\n      var shapes = newShapes(outlines, dragOptions);\n\n      if (shapes) {\n        Registry.call('_guiRelayout', gd, {\n          shapes: shapes\n        });\n      }\n\n      gd._fullLayout._drawing = false;\n    }\n  }\n\n  plotinfo.selection = {};\n  plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n  plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\n\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n  var searchTraces = [];\n  var xAxisIds = xAxes.map(function (ax) {\n    return ax._id;\n  });\n  var yAxisIds = yAxes.map(function (ax) {\n    return ax._id;\n  });\n  var cd, trace, i;\n\n  for (i = 0; i < gd.calcdata.length; i++) {\n    cd = gd.calcdata[i];\n    trace = cd[0].trace;\n    if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n\n    if (subplot && (trace.subplot === subplot || trace.geo === subplot)) {\n      searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n    } else if (trace.type === 'splom' && // FIXME: make sure we don't have more than single axis for splom\n    trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {\n      var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      info.scene = gd._fullLayout._splomScenes[trace.uid];\n      searchTraces.push(info);\n    } else if (trace.type === 'sankey') {\n      var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      searchTraces.push(sankeyInfo);\n    } else {\n      if (xAxisIds.indexOf(trace.xaxis) === -1) continue;\n      if (yAxisIds.indexOf(trace.yaxis) === -1) continue;\n      searchTraces.push(createSearchInfo(trace._module, cd, getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n    }\n  }\n\n  return searchTraces;\n\n  function createSearchInfo(module, calcData, xaxis, yaxis) {\n    return {\n      _module: module,\n      cd: calcData,\n      xaxis: xaxis,\n      yaxis: yaxis\n    };\n  }\n}\n\nfunction isHoverDataSet(hoverData) {\n  return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;\n}\n\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n  var hoverDatum = hoverData[0];\n  var pointNumber = -1;\n  var pointNumbers = [];\n  var searchInfo, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n\n    if (hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n      // Special case for box (and violin)\n      if (hoverDatum.hoverOnBox === true) {\n        break;\n      } // Hint: in some traces like histogram, one graphical element\n      // doesn't correspond to one particular data point, but to\n      // bins of data points. Thus, hoverDatum can have a binNumber\n      // property instead of pointNumber.\n\n\n      if (hoverDatum.pointNumber !== undefined) {\n        pointNumber = hoverDatum.pointNumber;\n      } else if (hoverDatum.binNumber !== undefined) {\n        pointNumber = hoverDatum.binNumber;\n        pointNumbers = hoverDatum.pointNumbers;\n      }\n\n      break;\n    }\n  }\n\n  return {\n    pointNumber: pointNumber,\n    pointNumbers: pointNumbers,\n    searchInfo: searchInfo\n  };\n}\n\nfunction isPointOrBinSelected(clickedPtInfo) {\n  var trace = clickedPtInfo.searchInfo.cd[0].trace;\n  var ptNum = clickedPtInfo.pointNumber;\n  var ptNums = clickedPtInfo.pointNumbers;\n  var ptNumsSet = ptNums.length > 0; // When pointsNumbers is set (e.g. histogram's binning),\n  // it is assumed that when the first point of\n  // a bin is selected, all others are as well\n\n  var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum; // TODO potential performance improvement\n  // Primarily we need this function to determine if a click adds\n  // or subtracts from a selection.\n  // In cases `trace.selectedpoints` is a huge array, indexOf\n  // might be slow. One remedy would be to introduce a hash somewhere.\n\n  return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\n\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n  var tracesWithSelectedPts = [];\n  var searchInfo, trace, isSameTrace, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n\n    if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n      tracesWithSelectedPts.push(searchInfo);\n    }\n  }\n\n  if (tracesWithSelectedPts.length === 1) {\n    isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n\n    if (isSameTrace) {\n      trace = clickedPtInfo.searchInfo.cd[0].trace;\n\n      if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n        for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n          if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isOnlyOnePointSelected(searchTraces) {\n  var len = 0;\n  var searchInfo, trace, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    trace = searchInfo.cd[0].trace;\n\n    if (trace.selectedpoints) {\n      if (trace.selectedpoints.length > 1) return false;\n      len += trace.selectedpoints.length;\n      if (len > 1) return false;\n    }\n  }\n\n  return len === 1;\n}\n\nfunction updateSelectedState(gd, searchTraces, eventData) {\n  var i, searchInfo, cd, trace; // before anything else, update preGUI if necessary\n\n  for (i = 0; i < searchTraces.length; i++) {\n    var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n    var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n\n    if (tracePreGUI.selectedpoints === undefined) {\n      tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n    }\n  }\n\n  if (eventData) {\n    var pts = eventData.points || [];\n\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n      if (trace._fullInput !== trace) trace.selectedpoints = [];\n    }\n\n    for (i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n      var data = pt.data;\n      var fullData = pt.fullData;\n\n      if (pt.pointIndices) {\n        [].push.apply(data.selectedpoints, pt.pointIndices);\n\n        if (trace._fullInput !== trace) {\n          [].push.apply(fullData.selectedpoints, pt.pointIndices);\n        }\n      } else {\n        data.selectedpoints.push(pt.pointIndex);\n\n        if (trace._fullInput !== trace) {\n          fullData.selectedpoints.push(pt.pointIndex);\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      delete trace.selectedpoints;\n      delete trace._input.selectedpoints;\n\n      if (trace._fullInput !== trace) {\n        delete trace._fullInput.selectedpoints;\n      }\n    }\n  }\n\n  var hasRegl = false;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    cd = searchInfo.cd;\n    trace = cd[0].trace;\n\n    if (Registry.traceIs(trace, 'regl')) {\n      hasRegl = true;\n    }\n\n    var _module = searchInfo._module;\n    var fn = _module.styleOnSelect || _module.style;\n\n    if (fn) {\n      fn(gd, cd, cd[0].node3);\n      if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n    }\n  }\n\n  if (hasRegl) {\n    clearGlCanvases(gd);\n    redrawReglTraces(gd);\n  }\n}\n\nfunction mergePolygons(list, poly, subtract) {\n  var res;\n\n  if (subtract) {\n    res = polybool.difference({\n      regions: list,\n      inverted: false\n    }, {\n      regions: [poly],\n      inverted: false\n    });\n    return res.regions;\n  }\n\n  res = polybool.union({\n    regions: list,\n    inverted: false\n  }, {\n    regions: [poly],\n    inverted: false\n  });\n  return res.regions;\n}\n\nfunction fillSelectionItem(selection, searchInfo) {\n  if (Array.isArray(selection)) {\n    var cd = searchInfo.cd;\n    var trace = searchInfo.cd[0].trace;\n\n    for (var i = 0; i < selection.length; i++) {\n      selection[i] = makeEventData(selection[i], trace, cd);\n    }\n  }\n\n  return selection;\n}\n\nfunction convertPoly(polygonsIn, isOpenMode) {\n  // add M and L command to draft positions\n  var polygonsOut = [];\n\n  for (var i = 0; i < polygonsIn.length; i++) {\n    polygonsOut[i] = [];\n\n    for (var j = 0; j < polygonsIn[i].length; j++) {\n      polygonsOut[i][j] = [];\n      polygonsOut[i][j][0] = j ? 'L' : 'M';\n\n      for (var k = 0; k < polygonsIn[i][j].length; k++) {\n        polygonsOut[i][j].push(polygonsIn[i][j][k]);\n      }\n    }\n\n    if (!isOpenMode) {\n      polygonsOut[i].push(['Z', polygonsOut[i][0][1], // initial x\n      polygonsOut[i][0][2] // initial y\n      ]);\n    }\n  }\n\n  return polygonsOut;\n}\n\nmodule.exports = {\n  prepSelect: prepSelect,\n  clearSelect: clearSelect,\n  clearSelectionsCache: clearSelectionsCache,\n  selectOnClick: selectOnClick\n};","map":null,"metadata":{},"sourceType":"script"}