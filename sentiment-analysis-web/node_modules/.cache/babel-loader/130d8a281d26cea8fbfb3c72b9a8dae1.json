{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\n\nvar Events = require('../../lib/events');\n\nvar dragElement = require('../dragelement');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar handleClick = require('./handle_click');\n\nvar constants = require('./constants');\n\nvar alignmentConstants = require('../../constants/alignment');\n\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nvar getLegendData = require('./get_legend_data');\n\nvar style = require('./style');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function draw(gd, opts) {\n  var fullLayout = gd._fullLayout;\n  var clipId = 'legend' + fullLayout._uid;\n  var layer; // Check whether this is the main legend (ie. called without any opts)\n\n  if (!opts) {\n    opts = fullLayout.legend || {};\n    opts._main = true;\n    layer = fullLayout._infolayer;\n  } else {\n    layer = opts.layer;\n    clipId += '-hover';\n  }\n\n  if (!layer) return;\n  if (!gd._legendMouseDownTime) gd._legendMouseDownTime = 0;\n  var legendData;\n\n  if (opts._main) {\n    if (!gd.calcdata) return;\n    legendData = fullLayout.showlegend && getLegendData(gd.calcdata, opts);\n  } else {\n    if (!opts.entries) return;\n    legendData = getLegendData(opts.entries, opts);\n  }\n\n  var hiddenSlices = fullLayout.hiddenlabels || [];\n\n  if (opts._main && (!fullLayout.showlegend || !legendData.length)) {\n    layer.selectAll('.legend').remove();\n\n    fullLayout._topdefs.select('#' + clipId).remove();\n\n    return Plots.autoMargin(gd, 'legend');\n  }\n\n  var legend = Lib.ensureSingle(layer, 'g', 'legend', function (s) {\n    if (opts._main) s.attr('pointer-events', 'all');\n  });\n  var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', clipId, function (s) {\n    s.append('rect');\n  });\n  var bg = Lib.ensureSingle(legend, 'rect', 'bg', function (s) {\n    s.attr('shape-rendering', 'crispEdges');\n  });\n  bg.call(Color.stroke, opts.bordercolor).call(Color.fill, opts.bgcolor).style('stroke-width', opts.borderwidth + 'px');\n  var scrollBox = Lib.ensureSingle(legend, 'g', 'scrollbox');\n  var title = opts.title;\n  opts._titleWidth = 0;\n  opts._titleHeight = 0;\n\n  if (title.text) {\n    var titleEl = Lib.ensureSingle(scrollBox, 'text', 'legendtitletext');\n    titleEl.attr('text-anchor', 'start').call(Drawing.font, title.font).text(title.text);\n    textLayout(titleEl, scrollBox, gd, opts); // handle mathjax or multi-line text and compute title height\n  } else {\n    scrollBox.selectAll('.legendtitletext').remove();\n  }\n\n  var scrollBar = Lib.ensureSingle(legend, 'rect', 'scrollbar', function (s) {\n    s.attr(constants.scrollBarEnterAttrs).call(Color.fill, constants.scrollBarColor);\n  });\n  var groups = scrollBox.selectAll('g.groups').data(legendData);\n  groups.enter().append('g').attr('class', 'groups');\n  groups.exit().remove();\n  var traces = groups.selectAll('g.traces').data(Lib.identity);\n  traces.enter().append('g').attr('class', 'traces');\n  traces.exit().remove();\n  traces.style('opacity', function (d) {\n    var trace = d[0].trace;\n\n    if (Registry.traceIs(trace, 'pie-like')) {\n      return hiddenSlices.indexOf(d[0].label) !== -1 ? 0.5 : 1;\n    } else {\n      return trace.visible === 'legendonly' ? 0.5 : 1;\n    }\n  }).each(function () {\n    d3.select(this).call(drawTexts, gd, opts);\n  }).call(style, gd, opts).each(function () {\n    if (opts._main) d3.select(this).call(setupTraceToggle, gd);\n  });\n  Lib.syncOrAsync([Plots.previousPromises, function () {\n    return computeLegendDimensions(gd, groups, traces, opts);\n  }, function () {\n    // IF expandMargin return a Promise (which is truthy),\n    // we're under a doAutoMargin redraw, so we don't have to\n    // draw the remaining pieces below\n    if (opts._main && expandMargin(gd)) return;\n    var gs = fullLayout._size;\n    var bw = opts.borderwidth;\n\n    var lx = gs.l + gs.w * opts.x - FROM_TL[getXanchor(opts)] * opts._width;\n\n    var ly = gs.t + gs.h * (1 - opts.y) - FROM_TL[getYanchor(opts)] * opts._effHeight;\n\n    if (opts._main && fullLayout.margin.autoexpand) {\n      var lx0 = lx;\n      var ly0 = ly;\n      lx = Lib.constrain(lx, 0, fullLayout.width - opts._width);\n      ly = Lib.constrain(ly, 0, fullLayout.height - opts._effHeight);\n\n      if (lx !== lx0) {\n        Lib.log('Constrain legend.x to make legend fit inside graph');\n      }\n\n      if (ly !== ly0) {\n        Lib.log('Constrain legend.y to make legend fit inside graph');\n      }\n    } // Set size and position of all the elements that make up a legend:\n    // legend, background and border, scroll box and scroll bar as well as title\n\n\n    if (opts._main) Drawing.setTranslate(legend, lx, ly); // to be safe, remove previous listeners\n\n    scrollBar.on('.drag', null);\n    legend.on('wheel', null);\n\n    if (!opts._main || opts._height <= opts._maxHeight || gd._context.staticPlot) {\n      // if scrollbar should not be shown.\n      var height = opts._effHeight; // if not the main legend, let it be its full size\n\n      if (!opts._main) height = opts._height;\n      bg.attr({\n        width: opts._width - bw,\n        height: height - bw,\n        x: bw / 2,\n        y: bw / 2\n      });\n      Drawing.setTranslate(scrollBox, 0, 0);\n      clipPath.select('rect').attr({\n        width: opts._width - 2 * bw,\n        height: height - 2 * bw,\n        x: bw,\n        y: bw\n      });\n      Drawing.setClipUrl(scrollBox, clipId, gd);\n      Drawing.setRect(scrollBar, 0, 0, 0, 0);\n      delete opts._scrollY;\n    } else {\n      var scrollBarHeight = Math.max(constants.scrollBarMinHeight, opts._effHeight * opts._effHeight / opts._height);\n      var scrollBarYMax = opts._effHeight - scrollBarHeight - 2 * constants.scrollBarMargin;\n      var scrollBoxYMax = opts._height - opts._effHeight;\n      var scrollRatio = scrollBarYMax / scrollBoxYMax;\n      var scrollBoxY = Math.min(opts._scrollY || 0, scrollBoxYMax); // increase the background and clip-path width\n      // by the scrollbar width and margin\n\n      bg.attr({\n        width: opts._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,\n        height: opts._effHeight - bw,\n        x: bw / 2,\n        y: bw / 2\n      });\n      clipPath.select('rect').attr({\n        width: opts._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,\n        height: opts._effHeight - 2 * bw,\n        x: bw,\n        y: bw + scrollBoxY\n      });\n      Drawing.setClipUrl(scrollBox, clipId, gd);\n      scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio); // scroll legend by mousewheel or touchpad swipe up/down\n\n      legend.on('wheel', function () {\n        scrollBoxY = Lib.constrain(opts._scrollY + d3.event.deltaY / scrollBarYMax * scrollBoxYMax, 0, scrollBoxYMax);\n        scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);\n\n        if (scrollBoxY !== 0 && scrollBoxY !== scrollBoxYMax) {\n          d3.event.preventDefault();\n        }\n      });\n      var eventY0, eventY1, scrollBoxY0;\n\n      var getScrollBarDragY = function getScrollBarDragY(scrollBoxY0, eventY0, eventY1) {\n        var y = (eventY1 - eventY0) / scrollRatio + scrollBoxY0;\n        return Lib.constrain(y, 0, scrollBoxYMax);\n      };\n\n      var getNaturalDragY = function getNaturalDragY(scrollBoxY0, eventY0, eventY1) {\n        var y = (eventY0 - eventY1) / scrollRatio + scrollBoxY0;\n        return Lib.constrain(y, 0, scrollBoxYMax);\n      }; // scroll legend by dragging scrollBAR\n\n\n      var scrollBarDrag = d3.behavior.drag().on('dragstart', function () {\n        var e = d3.event.sourceEvent;\n\n        if (e.type === 'touchstart') {\n          eventY0 = e.changedTouches[0].clientY;\n        } else {\n          eventY0 = e.clientY;\n        }\n\n        scrollBoxY0 = scrollBoxY;\n      }).on('drag', function () {\n        var e = d3.event.sourceEvent;\n        if (e.buttons === 2 || e.ctrlKey) return;\n\n        if (e.type === 'touchmove') {\n          eventY1 = e.changedTouches[0].clientY;\n        } else {\n          eventY1 = e.clientY;\n        }\n\n        scrollBoxY = getScrollBarDragY(scrollBoxY0, eventY0, eventY1);\n        scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);\n      });\n      scrollBar.call(scrollBarDrag); // scroll legend by touch-dragging scrollBOX\n\n      var scrollBoxTouchDrag = d3.behavior.drag().on('dragstart', function () {\n        var e = d3.event.sourceEvent;\n\n        if (e.type === 'touchstart') {\n          eventY0 = e.changedTouches[0].clientY;\n          scrollBoxY0 = scrollBoxY;\n        }\n      }).on('drag', function () {\n        var e = d3.event.sourceEvent;\n\n        if (e.type === 'touchmove') {\n          eventY1 = e.changedTouches[0].clientY;\n          scrollBoxY = getNaturalDragY(scrollBoxY0, eventY0, eventY1);\n          scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);\n        }\n      });\n      scrollBox.call(scrollBoxTouchDrag);\n    }\n\n    function scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio) {\n      opts._scrollY = gd._fullLayout.legend._scrollY = scrollBoxY;\n      Drawing.setTranslate(scrollBox, 0, -scrollBoxY);\n      Drawing.setRect(scrollBar, opts._width, constants.scrollBarMargin + scrollBoxY * scrollRatio, constants.scrollBarWidth, scrollBarHeight);\n      clipPath.select('rect').attr('y', bw + scrollBoxY);\n    }\n\n    if (gd._context.edits.legendPosition) {\n      var xf, yf, x0, y0;\n      legend.classed('cursor-move', true);\n      dragElement.init({\n        element: legend.node(),\n        gd: gd,\n        prepFn: function prepFn() {\n          var transform = Drawing.getTranslate(legend);\n          x0 = transform.x;\n          y0 = transform.y;\n        },\n        moveFn: function moveFn(dx, dy) {\n          var newX = x0 + dx;\n          var newY = y0 + dy;\n          Drawing.setTranslate(legend, newX, newY);\n          xf = dragElement.align(newX, 0, gs.l, gs.l + gs.w, opts.xanchor);\n          yf = dragElement.align(newY, 0, gs.t + gs.h, gs.t, opts.yanchor);\n        },\n        doneFn: function doneFn() {\n          if (xf !== undefined && yf !== undefined) {\n            Registry.call('_guiRelayout', gd, {\n              'legend.x': xf,\n              'legend.y': yf\n            });\n          }\n        },\n        clickFn: function clickFn(numClicks, e) {\n          var clickedTrace = layer.selectAll('g.traces').filter(function () {\n            var bbox = this.getBoundingClientRect();\n            return e.clientX >= bbox.left && e.clientX <= bbox.right && e.clientY >= bbox.top && e.clientY <= bbox.bottom;\n          });\n\n          if (clickedTrace.size() > 0) {\n            clickOrDoubleClick(gd, legend, clickedTrace, numClicks, e);\n          }\n        }\n      });\n    }\n  }], gd);\n};\n\nfunction clickOrDoubleClick(gd, legend, legendItem, numClicks, evt) {\n  var trace = legendItem.data()[0][0].trace;\n  var evtData = {\n    event: evt,\n    node: legendItem.node(),\n    curveNumber: trace.index,\n    expandedIndex: trace._expandedIndex,\n    data: gd.data,\n    layout: gd.layout,\n    frames: gd._transitionData._frames,\n    config: gd._context,\n    fullData: gd._fullData,\n    fullLayout: gd._fullLayout\n  };\n\n  if (trace._group) {\n    evtData.group = trace._group;\n  }\n\n  if (Registry.traceIs(trace, 'pie-like')) {\n    evtData.label = legendItem.datum()[0].label;\n  }\n\n  var clickVal = Events.triggerHandler(gd, 'plotly_legendclick', evtData);\n  if (clickVal === false) return;\n\n  if (numClicks === 1) {\n    legend._clickTimeout = setTimeout(function () {\n      handleClick(legendItem, gd, numClicks);\n    }, gd._context.doubleClickDelay);\n  } else if (numClicks === 2) {\n    if (legend._clickTimeout) clearTimeout(legend._clickTimeout);\n    gd._legendMouseDownTime = 0;\n    var dblClickVal = Events.triggerHandler(gd, 'plotly_legenddoubleclick', evtData);\n    if (dblClickVal !== false) handleClick(legendItem, gd, numClicks);\n  }\n}\n\nfunction drawTexts(g, gd, opts) {\n  var legendItem = g.data()[0][0];\n  var trace = legendItem.trace;\n  var isPieLike = Registry.traceIs(trace, 'pie-like');\n  var traceIndex = trace.index;\n  var isEditable = opts._main && gd._context.edits.legendText && !isPieLike;\n  var maxNameLength = opts._maxNameLength;\n  var name;\n\n  if (!opts.entries) {\n    name = isPieLike ? legendItem.label : trace.name;\n\n    if (trace._meta) {\n      name = Lib.templateString(name, trace._meta);\n    }\n  } else {\n    name = legendItem.text;\n  }\n\n  var textEl = Lib.ensureSingle(g, 'text', 'legendtext');\n  textEl.attr('text-anchor', 'start').call(Drawing.font, opts.font).text(isEditable ? ensureLength(name, maxNameLength) : name);\n  var textGap = opts.itemwidth + constants.itemGap * 2;\n  svgTextUtils.positionText(textEl, textGap, 0);\n\n  if (isEditable) {\n    textEl.call(svgTextUtils.makeEditable, {\n      gd: gd,\n      text: name\n    }).call(textLayout, g, gd, opts).on('edit', function (newName) {\n      this.text(ensureLength(newName, maxNameLength)).call(textLayout, g, gd, opts);\n      var fullInput = legendItem.trace._fullInput || {};\n      var update = {};\n\n      if (Registry.hasTransform(fullInput, 'groupby')) {\n        var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n        var index = groupbyIndices[groupbyIndices.length - 1];\n        var kcont = Lib.keyedContainer(fullInput, 'transforms[' + index + '].styles', 'target', 'value.name');\n        kcont.set(legendItem.trace._group, newName);\n        update = kcont.constructUpdate();\n      } else {\n        update.name = newName;\n      }\n\n      return Registry.call('_guiRestyle', gd, update, traceIndex);\n    });\n  } else {\n    textLayout(textEl, g, gd, opts);\n  }\n}\n/*\n * Make sure we have a reasonably clickable region.\n * If this string is missing or very short, pad it with spaces out to at least\n * 4 characters, up to the max length of other labels, on the assumption that\n * most characters are wider than spaces so a string of spaces will usually be\n * no wider than the real labels.\n */\n\n\nfunction ensureLength(str, maxLength) {\n  var targetLength = Math.max(4, maxLength);\n  if (str && str.trim().length >= targetLength / 2) return str;\n  str = str || '';\n\n  for (var i = targetLength - str.length; i > 0; i--) {\n    str += ' ';\n  }\n\n  return str;\n}\n\nfunction setupTraceToggle(g, gd) {\n  var doubleClickDelay = gd._context.doubleClickDelay;\n  var newMouseDownTime;\n  var numClicks = 1;\n  var traceToggle = Lib.ensureSingle(g, 'rect', 'legendtoggle', function (s) {\n    if (!gd._context.staticPlot) {\n      s.style('cursor', 'pointer').attr('pointer-events', 'all');\n    }\n\n    s.call(Color.fill, 'rgba(0,0,0,0)');\n  });\n  if (gd._context.staticPlot) return;\n  traceToggle.on('mousedown', function () {\n    newMouseDownTime = new Date().getTime();\n\n    if (newMouseDownTime - gd._legendMouseDownTime < doubleClickDelay) {\n      // in a click train\n      numClicks += 1;\n    } else {\n      // new click train\n      numClicks = 1;\n      gd._legendMouseDownTime = newMouseDownTime;\n    }\n  });\n  traceToggle.on('mouseup', function () {\n    if (gd._dragged || gd._editing) return;\n    var legend = gd._fullLayout.legend;\n\n    if (new Date().getTime() - gd._legendMouseDownTime > doubleClickDelay) {\n      numClicks = Math.max(numClicks - 1, 1);\n    }\n\n    clickOrDoubleClick(gd, legend, g, numClicks, d3.event);\n  });\n}\n\nfunction textLayout(s, g, gd, opts) {\n  if (!opts._main) s.attr('data-notex', true); // do not process MathJax if not main\n\n  svgTextUtils.convertToTspans(s, gd, function () {\n    computeTextDimensions(g, gd, opts);\n  });\n}\n\nfunction computeTextDimensions(g, gd, opts) {\n  var legendItem = g.data()[0][0];\n\n  if (opts._main && legendItem && !legendItem.trace.showlegend) {\n    g.remove();\n    return;\n  }\n\n  var mathjaxGroup = g.select('g[class*=math-group]');\n  var mathjaxNode = mathjaxGroup.node();\n  if (!opts) opts = gd._fullLayout.legend;\n  var bw = opts.borderwidth;\n  var lineHeight = (legendItem ? opts : opts.title).font.size * LINE_SPACING;\n  var height, width;\n\n  if (mathjaxNode) {\n    var mathjaxBB = Drawing.bBox(mathjaxNode);\n    height = mathjaxBB.height;\n    width = mathjaxBB.width;\n\n    if (legendItem) {\n      Drawing.setTranslate(mathjaxGroup, 0, height * 0.25);\n    } else {\n      // case of title\n      Drawing.setTranslate(mathjaxGroup, bw, height * 0.75 + bw);\n    }\n  } else {\n    var textEl = g.select(legendItem ? '.legendtext' : '.legendtitletext');\n    var textLines = svgTextUtils.lineCount(textEl);\n    var textNode = textEl.node();\n    height = lineHeight * textLines;\n    width = textNode ? Drawing.bBox(textNode).width : 0; // approximation to height offset to center the font\n    // to avoid getBoundingClientRect\n\n    var textY = lineHeight * ((textLines - 1) / 2 - 0.3);\n\n    if (legendItem) {\n      var textGap = opts.itemwidth + constants.itemGap * 2;\n      svgTextUtils.positionText(textEl, textGap, -textY);\n    } else {\n      // case of title\n      svgTextUtils.positionText(textEl, constants.titlePad + bw, lineHeight + bw);\n    }\n  }\n\n  if (legendItem) {\n    legendItem.lineHeight = lineHeight;\n    legendItem.height = Math.max(height, 16) + 3;\n    legendItem.width = width;\n  } else {\n    // case of title\n    opts._titleWidth = width;\n    opts._titleHeight = height;\n  }\n}\n\nfunction getTitleSize(opts) {\n  var w = 0;\n  var h = 0;\n  var side = opts.title.side;\n\n  if (side) {\n    if (side.indexOf('left') !== -1) {\n      w = opts._titleWidth;\n    }\n\n    if (side.indexOf('top') !== -1) {\n      h = opts._titleHeight;\n    }\n  }\n\n  return [w, h];\n}\n/*\n * Computes in fullLayout.legend:\n *\n *  - _height: legend height including items past scrollbox height\n *  - _maxHeight: maximum legend height before scrollbox is required\n *  - _effHeight: legend height w/ or w/o scrollbox\n *\n *  - _width: legend width\n *  - _maxWidth (for orientation:h only): maximum width before starting new row\n */\n\n\nfunction computeLegendDimensions(gd, groups, traces, opts) {\n  var fullLayout = gd._fullLayout;\n  if (!opts) opts = fullLayout.legend;\n  var gs = fullLayout._size;\n  var isVertical = helpers.isVertical(opts);\n  var isGrouped = helpers.isGrouped(opts);\n  var bw = opts.borderwidth;\n  var bw2 = 2 * bw;\n  var itemGap = constants.itemGap;\n  var textGap = opts.itemwidth + itemGap * 2;\n  var endPad = 2 * (bw + itemGap);\n  var yanchor = getYanchor(opts);\n  var isBelowPlotArea = opts.y < 0 || opts.y === 0 && yanchor === 'top';\n  var isAbovePlotArea = opts.y > 1 || opts.y === 1 && yanchor === 'bottom'; // - if below/above plot area, give it the maximum potential margin-push value\n  // - otherwise, extend the height of the plot area\n\n  opts._maxHeight = Math.max(isBelowPlotArea || isAbovePlotArea ? fullLayout.height / 2 : gs.h, 30);\n  var toggleRectWidth = 0;\n  opts._width = 0;\n  opts._height = 0;\n  var titleSize = getTitleSize(opts);\n\n  if (isVertical) {\n    traces.each(function (d) {\n      var h = d[0].height;\n      Drawing.setTranslate(this, bw + titleSize[0], bw + titleSize[1] + opts._height + h / 2 + itemGap);\n      opts._height += h;\n      opts._width = Math.max(opts._width, d[0].width);\n    });\n    toggleRectWidth = textGap + opts._width;\n    opts._width += itemGap + textGap + bw2;\n    opts._height += endPad;\n\n    if (isGrouped) {\n      groups.each(function (d, i) {\n        Drawing.setTranslate(this, 0, i * opts.tracegroupgap);\n      });\n      opts._height += (opts._lgroupsLength - 1) * opts.tracegroupgap;\n    }\n  } else {\n    var xanchor = getXanchor(opts);\n    var isLeftOfPlotArea = opts.x < 0 || opts.x === 0 && xanchor === 'right';\n    var isRightOfPlotArea = opts.x > 1 || opts.x === 1 && xanchor === 'left';\n    var isBeyondPlotAreaY = isAbovePlotArea || isBelowPlotArea;\n    var hw = fullLayout.width / 2; // - if placed within x-margins, extend the width of the plot area\n    // - else if below/above plot area and anchored in the margin, extend to opposite margin,\n    // - otherwise give it the maximum potential margin-push value\n\n    opts._maxWidth = Math.max(isLeftOfPlotArea ? isBeyondPlotAreaY && xanchor === 'left' ? gs.l + gs.w : hw : isRightOfPlotArea ? isBeyondPlotAreaY && xanchor === 'right' ? gs.r + gs.w : hw : gs.w, 2 * textGap);\n    var maxItemWidth = 0;\n    var combinedItemWidth = 0;\n    traces.each(function (d) {\n      var w = d[0].width + textGap;\n      maxItemWidth = Math.max(maxItemWidth, w);\n      combinedItemWidth += w;\n    });\n    toggleRectWidth = null;\n    var maxRowWidth = 0;\n\n    if (isGrouped) {\n      var maxGroupHeightInRow = 0;\n      var groupOffsetX = 0;\n      var groupOffsetY = 0;\n      groups.each(function () {\n        var maxWidthInGroup = 0;\n        var offsetY = 0;\n        d3.select(this).selectAll('g.traces').each(function (d) {\n          var h = d[0].height;\n          Drawing.setTranslate(this, titleSize[0], titleSize[1] + bw + itemGap + h / 2 + offsetY);\n          offsetY += h;\n          maxWidthInGroup = Math.max(maxWidthInGroup, textGap + d[0].width);\n        });\n        maxGroupHeightInRow = Math.max(maxGroupHeightInRow, offsetY);\n        var next = maxWidthInGroup + itemGap;\n\n        if (next + bw + groupOffsetX > opts._maxWidth) {\n          maxRowWidth = Math.max(maxRowWidth, groupOffsetX);\n          groupOffsetX = 0;\n          groupOffsetY += maxGroupHeightInRow + opts.tracegroupgap;\n          maxGroupHeightInRow = offsetY;\n        }\n\n        Drawing.setTranslate(this, groupOffsetX, groupOffsetY);\n        groupOffsetX += next;\n      });\n      opts._width = Math.max(maxRowWidth, groupOffsetX) + bw;\n      opts._height = groupOffsetY + maxGroupHeightInRow + endPad;\n    } else {\n      var nTraces = traces.size();\n      var oneRowLegend = combinedItemWidth + bw2 + (nTraces - 1) * itemGap < opts._maxWidth;\n      var maxItemHeightInRow = 0;\n      var offsetX = 0;\n      var offsetY = 0;\n      var rowWidth = 0;\n      traces.each(function (d) {\n        var h = d[0].height;\n        var w = textGap + d[0].width;\n        var next = (oneRowLegend ? w : maxItemWidth) + itemGap;\n\n        if (next + bw + offsetX - itemGap >= opts._maxWidth) {\n          maxRowWidth = Math.max(maxRowWidth, rowWidth);\n          offsetX = 0;\n          offsetY += maxItemHeightInRow;\n          opts._height += maxItemHeightInRow;\n          maxItemHeightInRow = 0;\n        }\n\n        Drawing.setTranslate(this, titleSize[0] + bw + offsetX, titleSize[1] + bw + offsetY + h / 2 + itemGap);\n        rowWidth = offsetX + w + itemGap;\n        offsetX += next;\n        maxItemHeightInRow = Math.max(maxItemHeightInRow, h);\n      });\n\n      if (oneRowLegend) {\n        opts._width = offsetX + bw2;\n        opts._height = maxItemHeightInRow + endPad;\n      } else {\n        opts._width = Math.max(maxRowWidth, rowWidth) + bw2;\n        opts._height += maxItemHeightInRow + endPad;\n      }\n    }\n  }\n\n  opts._width = Math.ceil(Math.max(opts._width + titleSize[0], opts._titleWidth + 2 * (bw + constants.titlePad)));\n  opts._height = Math.ceil(Math.max(opts._height + titleSize[1], opts._titleHeight + 2 * (bw + constants.itemGap)));\n  opts._effHeight = Math.min(opts._height, opts._maxHeight);\n  var edits = gd._context.edits;\n  var isEditable = edits.legendText || edits.legendPosition;\n  traces.each(function (d) {\n    var traceToggle = d3.select(this).select('.legendtoggle');\n    var h = d[0].height;\n    var w = isEditable ? textGap : toggleRectWidth || textGap + d[0].width;\n    if (!isVertical) w += itemGap / 2;\n    Drawing.setRect(traceToggle, 0, -h / 2, w, h);\n  });\n}\n\nfunction expandMargin(gd) {\n  var fullLayout = gd._fullLayout;\n  var opts = fullLayout.legend;\n  var xanchor = getXanchor(opts);\n  var yanchor = getYanchor(opts);\n  return Plots.autoMargin(gd, 'legend', {\n    x: opts.x,\n    y: opts.y,\n    l: opts._width * FROM_TL[xanchor],\n    r: opts._width * FROM_BR[xanchor],\n    b: opts._effHeight * FROM_BR[yanchor],\n    t: opts._effHeight * FROM_TL[yanchor]\n  });\n}\n\nfunction getXanchor(opts) {\n  return Lib.isRightAnchor(opts) ? 'right' : Lib.isCenterAnchor(opts) ? 'center' : 'left';\n}\n\nfunction getYanchor(opts) {\n  return Lib.isBottomAnchor(opts) ? 'bottom' : Lib.isMiddleAnchor(opts) ? 'middle' : 'top';\n}","map":null,"metadata":{},"sourceType":"script"}