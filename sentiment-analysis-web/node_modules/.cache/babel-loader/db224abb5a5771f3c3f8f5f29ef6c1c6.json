{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar typeHandlers = require('./types');\n\nvar detector = require('./detector'); // Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\n\n\nvar MaxBufferSize = 512 * 1024;\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\n\nfunction lookup(buffer, filepath) {\n  // detect the file type.. don't rely on the extension\n  var type = detector(buffer, filepath); // find an appropriate handler for this file type\n\n  if (type in typeHandlers) {\n    var size = typeHandlers[type].calculate(buffer, filepath);\n\n    if (size !== false) {\n      size.type = type;\n      return size;\n    }\n  } // throw up, if we don't understand the file\n\n\n  throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n *\n * The callback will be called after the process has completed. The\n * callback's first argument will be an error (or null). The second argument\n * will be the Buffer, if the operation was successful.\n *\n * @param {String} filepath\n * @param {Function} callback\n */\n\n\nfunction asyncFileToBuffer(filepath, callback) {\n  // open the file in read only mode\n  fs.open(filepath, 'r', function (err, descriptor) {\n    if (err) {\n      return callback(err);\n    }\n\n    fs.fstat(descriptor, function (err, stats) {\n      if (err) {\n        return callback(err);\n      }\n\n      var size = stats.size;\n\n      if (size <= 0) {\n        return callback(new Error('File size is not greater than 0 —— ' + filepath));\n      }\n\n      var bufferSize = Math.min(size, MaxBufferSize);\n      var buffer = Buffer.alloc(bufferSize); // read first buffer block from the file, asynchronously\n\n      fs.read(descriptor, buffer, 0, bufferSize, 0, function (err) {\n        if (err) {\n          return callback(err);\n        } // close the file, we are done\n\n\n        fs.close(descriptor, function (err) {\n          callback(err, buffer);\n        });\n      });\n    });\n  });\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\n\n\nfunction syncFileToBuffer(filepath) {\n  // read from the file, synchronously\n  var descriptor = fs.openSync(filepath, 'r');\n  var size = fs.fstatSync(descriptor).size;\n  var bufferSize = Math.min(size, MaxBufferSize);\n  var buffer = Buffer.alloc(bufferSize);\n  fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n  fs.closeSync(descriptor);\n  return buffer;\n}\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function=} callback - optional function for async detection\n */\n\n\nmodule.exports = function (input, callback) {\n  // Handle buffer input\n  if (Buffer.isBuffer(input)) {\n    return lookup(input);\n  } // input should be a string at this point\n\n\n  if (typeof input !== 'string') {\n    throw new TypeError('invalid invocation');\n  } // resolve the file path\n\n\n  var filepath = path.resolve(input);\n\n  if (typeof callback === 'function') {\n    asyncFileToBuffer(filepath, function (err, buffer) {\n      if (err) {\n        return callback(err);\n      } // return the dimensions\n\n\n      var dimensions;\n\n      try {\n        dimensions = lookup(buffer, filepath);\n      } catch (e) {\n        err = e;\n      }\n\n      callback(err, dimensions);\n    });\n  } else {\n    var buffer = syncFileToBuffer(filepath);\n    return lookup(buffer, filepath);\n  }\n};\n\nmodule.exports.types = Object.keys(typeHandlers);","map":null,"metadata":{},"sourceType":"script"}