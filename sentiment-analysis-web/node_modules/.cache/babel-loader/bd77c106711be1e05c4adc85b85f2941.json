{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib'); // special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V2.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\n\nexports.rangeToShapePosition = function (ax) {\n  return ax.type === 'log' ? ax.r2d : function (v) {\n    return v;\n  };\n};\n\nexports.shapePositionToRange = function (ax) {\n  return ax.type === 'log' ? ax.d2r : function (v) {\n    return v;\n  };\n};\n\nexports.decodeDate = function (convertToPx) {\n  return function (v) {\n    if (v.replace) v = v.replace('_', ' ');\n    return convertToPx(v);\n  };\n};\n\nexports.encodeDate = function (convertToDate) {\n  return function (v) {\n    return convertToDate(v).replace(' ', '_');\n  };\n};\n\nexports.extractPathCoords = function (path, paramsToUse) {\n  var extractedCoordinates = [];\n  var segments = path.match(constants.segmentRE);\n  segments.forEach(function (segment) {\n    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n    if (relevantParamIdx === undefined) return;\n    var params = segment.substr(1).match(constants.paramRE);\n    if (!params || params.length < relevantParamIdx) return;\n    extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));\n  });\n  return extractedCoordinates;\n};\n\nexports.getDataToPixel = function (gd, axis, isVertical, refType) {\n  var gs = gd._fullLayout._size;\n  var dataToPixel;\n\n  if (axis) {\n    if (refType === 'domain') {\n      dataToPixel = function dataToPixel(v) {\n        return axis._length * (isVertical ? 1 - v : v) + axis._offset;\n      };\n    } else {\n      var d2r = exports.shapePositionToRange(axis);\n\n      dataToPixel = function dataToPixel(v) {\n        return axis._offset + axis.r2p(d2r(v, true));\n      };\n\n      if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n    }\n  } else if (isVertical) {\n    dataToPixel = function dataToPixel(v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  } else {\n    dataToPixel = function dataToPixel(v) {\n      return gs.l + gs.w * v;\n    };\n  }\n\n  return dataToPixel;\n};\n\nexports.getPixelToData = function (gd, axis, isVertical, opt) {\n  var gs = gd._fullLayout._size;\n  var pixelToData;\n\n  if (axis) {\n    if (opt === 'domain') {\n      pixelToData = function pixelToData(p) {\n        var q = (p - axis._offset) / axis._length;\n        return isVertical ? 1 - q : q;\n      };\n    } else {\n      var r2d = exports.rangeToShapePosition(axis);\n\n      pixelToData = function pixelToData(p) {\n        return r2d(axis.p2r(p - axis._offset));\n      };\n    }\n  } else if (isVertical) {\n    pixelToData = function pixelToData(p) {\n      return 1 - (p - gs.t) / gs.h;\n    };\n  } else {\n    pixelToData = function pixelToData(p) {\n      return (p - gs.l) / gs.w;\n    };\n  }\n\n  return pixelToData;\n};\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\n\n\nexports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {\n  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n  var posValAsInt = Math.round(pos);\n  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n\nexports.makeOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.shapes[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n\n  plotinfo.xsizemode = options.xsizemode;\n  plotinfo.ysizemode = options.ysizemode;\n  plotinfo.xanchor = options.xanchor;\n  plotinfo.yanchor = options.yanchor;\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n};","map":null,"metadata":{},"sourceType":"script"}